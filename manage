#!/bin/env python2

"""
Module Manager

Start or stop a module.

Usage:
  module start <module_name> [--daemon]
  module stop <module_name>
  module status <module_name> [--porcelain]
  module (-h | --help)

Options:
  -h --help     Show this screen.
  --daemon      Start the module as a new daemon.
  --porcelain   Give the output in an easy-to-parse format for script.

"""

import os
import sys
sys.path.append('./core')
import shlex
import signal
import daemon
import logging
import subprocess
from module import get_pid_file, get_module_directory
from catalog import get_config

# popen object containing the child
child_proc = None

def signal_handler(signum, frame):
    """
    Signal handler. If no child was created, it does nothing.
    Else, it broadcasts the signal to the child.
    """
    global child_proc
    logger = logging.getLogger()
    logger.info('Receive a signal ' + str(signum) + '. Broadcast it to the child')
    if child_proc is not None:
        child_proc.send_signal(signum)
        child_proc.wait()

def exec_module(module_name, daemonize=True):
    """
    Start a new module identified by its name *module_name*. The current
    processus is killed at the end of the module when it's not a daemon. If it
    is, the current processus is killed immediately. Use *invoke_module*
    instead if you want to create a new killable process.
    """
    global child_proc

    # Check that only one instance is running at the same time
    pid_file = get_pid_file(module_name)
    if os.path.exists(pid_file):
        raise RuntimeError('A pid file already exists for this module')
        sys.exit(1)

    # Get the start command from the configuration file
    module_config = get_config(module_name)
    if not 'start' in module_config:
        raise RuntimeError(
                'Missing start entry in the module\'s configuration file')
    start_cmd = module_config['start']

    # Daemon or not Daemon ?
    if daemonize:
        # Create a daemon
        daemon.possess_me()

        # Redirect stdout and stderr into a log file
        sys.stdout = open(pid_file + '.log', 'a')
        sys.stderr = sys.stdout

    # Create a logger and return it
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)
    formatter = logging.Formatter(
            '%(asctime)s :: %(levelname)s :: %(message)s')
    handler = logging.StreamHandler()
    handler.setFormatter(formatter)
    handler.setLevel(logging.DEBUG)
    logger.addHandler(handler)

    # Change the directory to the module directory
    os.chdir(get_module_directory(module_name))

    # Prepare to receive signal SIGINT and SIGTERM
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    return_code = 0
    try:
        # Write the new daemon pid in a new file
        with open(pid_file, 'w') as f:
            f.write(str(os.getpid()))
            f.flush()
    except (OSError, IOError) as e:
        return_code = 1
    else:
        # Execute the start command
        logging.info('Start of the ' + module_name + ' module.')
        try:
            child_proc = subprocess.Popen(
                    shlex.split(start_cmd),
                    stdout=sys.stdout,
                    stderr=sys.stderr)
        except OSError as e:
            logging.exception(e)
            return_code = 1
        else:
            return_code = child_proc.wait()
    finally:
        # Remove the pid file and return the corresponding code
        logging.info('Shutdown of the ' + module_name + ' module.')
        os.remove(pid_file)
        sys.exit(return_code)

def invoke_module(module_name, daemonize=True):
    """
    As exec_module, execute a module but fork before to keep the current
    process active. To see if the module is really running, use the
    *status_module* function.
    Return the new process's pid.
    """
    pid = os.fork()
    if pid == 0: # Child side
        exec_module(module_name, daemonize)
    else: # Parent side
        return pid

def stop_module(module_name):
    """
    Stop the *module_name* module.
    """
    pid_file = get_pid_file(module_name)
    if not os.path.exists(pid_file):
        raise RuntimeError('The module `' + module_name + '`is not running')
        sys.exit(1)

    with open(pid_file, 'r') as f:
        pid = int(f.readline())
    os.kill(pid, signal.SIGTERM)

def status_module(module_name):
    """
    Return the status of the module *module_name*
    A module is considered as running if its pid file exists.
    Return true if the module is running else false.
    """
    pid_file = get_pid_file(module_name)
    return os.path.exists(pid_file)

if __name__ == '__main__':
    from docopt import docopt
    args = docopt(__doc__)

    if args['start']:
        exec_module(args['<module_name>'], args['--daemon'])
    elif args['stop']:
        stop_module(args['<module_name>'])
    elif args['status']:
        module_name = args['<module_name>']
        running = status_module(module_name)
        if args['--porcelain']:
            prefixe = 'R' if running else 'D'
            print prefixe, module_name
        else:
            if running:
                print 'The module', module_name, 'is running'
            else:
                print 'The module', module_name, 'is not running'
